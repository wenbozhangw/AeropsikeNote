## 冷启动恢复已删除记录的问题

### 概要

本文介绍了围绕非持久删除的记录在冷重启后恢复的各种情况

### 背景

#### Aerospike支持两种删除记录的方法：

1. **EXPUNGE** - 原始（和默认）删除，有时被称为 EXPUNGE，其中记录从索引中删除，从而将相应的条目保留在存储层上（如果命名空间持久化数据）。这样的删除会立即释放内存（每条记录 64
   字节）。磁盘上包含记录值的块将最终进行碎片整理（一旦其使用的容量降到 `defrag-lwm-pct` 阈值以下），并可以用于新的写入操作。仅当新的写入操作覆盖此类碎片整理的块时，才会从存储层中删除旧的记录值。

2. **Durable delete** - 从版本 3.10 开始，引入了新的客户端策略，该策略允许持久删除记录，以防止此类记录的旧版本在冷重启（或在特定时间内添加/删除节点）时重新出现。

文档涉及已删除（且为永久删除）记录的冷重启方案。

#### 记录从主索引取消引用的值

当服务器进行冷重启时，将扫描存储层以重建主索引。在某些情况下，从索引中取消引用的记录可能会再次被索引。

在 Aerospike （从主索引中取消引用）的持久存储层中，将记录值废弃的方法有以下几种：

1. 应用程序删除（包括删除记录的最后一个bin）。
2. 到期时间（用于设置了ttl的记录）。
3. 逐出（由于违反磁盘或内存高水位标记而导致记录被删除）。记录需要设置一个ttl才能被回收，如果没有ttl的记录，则记录不会过期也不会被回收。
4. 更新现有记录，因为 Aerospike 不会进行就地更新（它总是将新记录作为一个整体写在当前的streaming write buffer(swb)中，该缓冲区总是从一个完全空的块开始）。

#### 最后更新时间

从版本 3.8.3 开始，Aerospike在其元数据中添加了记录的最后更新时间，以用于冷重启期间的冲突解决。在引入上次更新时间之前，冲突解决是基于冷重启期间的 generation 完成的。

#### 在 3.8.3 之前的版本中

##### 1.记录更新了几次

- Record created (gen-1)
- Record updated (gen-2)
- Record updated (gen-3)

在最坏的情况下，冷重启时，磁盘上的所有 3 个版本的记录仍然存在（如果写操作未导致碎片胜利和覆盖这 3 个值所属的块）。

冷重启后，将扫描持久存储层，但是遇到记录的顺序取决于最初写入记录时最终如何分配记录，因此，通常可以按任何顺序遇到记录。假设记录的 gen-1 版本已被扫描并重新索引，然后是 gen-3 版本。读取 gen-3 时，将比较已索引版本的
generation，而更高版本的将会替换较旧版本的索引。

在这种情况下，无论记录的扫描顺序如何，具有更高 generation 的版本（gen-3）及都将成为最终索引。

**注意，记录的生成仅限于 65535，然后将绕回到1.因此，对于经常更新的记录，较旧版本的记录可能具有比较新版本有更高的generation。根据持久层上仍然存在的不同版本，较旧的版本可以再次出现，以替换较新的版本。**

##### 2.记录删除并重新创建

- Record created (gen-1)
- Record deleted
- Record re-created (gen-1)

前面的实例只有更新（没有删除）。在这里，创建了一条记录（gen-1），由应用程序删除并重新创建（再次创建时 gen-1，因为从索引的角度来看，它现在是一条新记录）。在此示例中，我们假设记录的原始版本仍存在与持久存储层上（未被覆盖）。

服务器冷重启时，将从磁盘扫描记录，并且可以首先扫描任意一个版本的记录（均带有gen-1）。如果这些记录是带有 TTL 的，则 TTL
将用于打破与无时间的练习，并使记录与最远的无效时间保持一致。由于在此示例中，两个记录都是在没有TTL的情况下写入的，因此不能这么判断，先扫描的记录优先。

因此，在这种情况下，冷重启后可能会重新索引错误的记录。

##### 3.记录更新几次然后删除

- Record created (gen-1)
- Record updated (gen-2)
- Record updated (gen-3)
- Record deleted

如果该记录的所有不同版本都没有在持久层上覆盖，则具有最高 generation （gen-3）的记录的版本将重新出现。

如果记录的某些版本在新的写入操作覆盖，则在持久层上仍存在的记录中generation最高的版本将在冷启动时重新索引。

如果所有版本都被覆盖，则该记录将不会重新出现。

##### 4.记录在没有ttl的情况下创建，但随后在ttl中更新

- Record created without a ttl (gen-1 / no ttl)
- Record updated with a ttl (gen-2 / ttl set)
- Record expires

在这种情况下，如果首先读取带有 gen-2 的版本，则该版本到期后将被跳过，但是如果再遇到 gen-1 的版本，它将被重新索引，因为此时索引中没有内容可以与该记录进行比较，并且此旧版本将在冷重启之后重新出现。

如果首先扫描 gen-1，他将被索引，但是如果仍然存在 gen-2 版本，则随着更高版本的过期，带有 gen-1 的版本将从索引中删除。然后再此特定情况下保证正确的状态。

##### 5.使用 ttl 创建的记录，然后使用 ttl 更新，这会使记录更早失效

- Record created with ttl1 (gen-1 / ttl1 - void time t1)
- Record updated with ttl2 (gen-2 / ttl2 - void time t2 < t1)
- Record expires

如果带有 gen-1 的记录仍在磁盘上，并且该记录的 gen-2 版本过期后发生冷重启，如果 gen-2 记录不在磁盘上（进行碎片整理后被新记录覆盖）或先被扫描（由于过期而将会被跳过），那么具有 gen-1 的记录将被复活。

#### 在版本 3.8.3 和最新更新时间的中

如本文前面所述，Aerospike 在 3.8.3 版本中引入了上次更新时间作为记录元数据的一部分。这代替了冷重启期间用于解决冲突的 generation。

##### 1. 记录更新

- Record created (gen-1)
- Record updated (gen-2)
- Record updated (gen-3)

由于带有 gen-3 的版本具有最新的上次更新时间，因此它将是主流版本。在更换 `generation` 的情况下，考虑到最后一次更新的时间是绝对的，并且保证记录的最新版本能够解决任何冲突，因此仍然以记录的正确版本为准。

##### 2.记录删除并重新创建

- Record created (gen-1)
- Record deleted
- Record re-created (gen-1)

在这种情况下，基于最新的更新时间的冲突解决方案可确保将最新版本重新编入索引，尽管可能具有统一 generation 的 两个版本的记录（如果最初的版本没有被新的写操作覆盖）。

##### 3.记录更新几次后删除

- Record created (gen-1)
- Record updated (gen-1)
- Record updated (gen-1)
- Record deleted

与版本3.8.3之前的示例3非常相似 ，基于持久层上仍存在的记录版本，具有最新上次更新时间的版本最终将在冷重启后重新索引。

##### 4.记录在没有ttl的情况下创建，但随后在ttl中更新

- Record created without a ttl (gen-1 / no ttl)
- Record updated with a ttl (gen-1 / ttl set)
- Record expires

同样，这与版本3.8.3之前的示例4非常相似。扫描不同版本的顺序确定了将重新索引的版本（如果有）。

##### 5.使用 ttl 创建的记录，然后使用 ttl 更新，这会使记录更早失效

- Record created with ttl (gen-1 / ttl - void time t1)
- Record updated with ttl (gen-2 / tt2 - void time t2 < t1)
- Record expires

如果带有 gen-1 的记录仍在磁盘上，并且该记录的 gen-2 版本过期后发生冷重启，如果 gen-2 记录不在磁盘上（进行碎片整理后被新纪录覆盖）或先被扫描（由于过期而将被跳过），那么具有 gen-1 的记录将被复活。


### XDR考虑
在设置 XDR 的情况下，即使迁移到另一个节点，也不会将其传送到任何目标集群，因为 XDR 仅会传送直接客户端（可能是另一个源 XDR 集群）写入操作产生的记录。

#### KEYWORDS
COLD RESTART DELETE RESTART ZOMBIE RESURRECTED