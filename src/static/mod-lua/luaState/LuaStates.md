## lua state

lua_State，我们可以认为是”脚本上下文”，主要是包括当前脚本环境的 lua 虚拟机中的环境表、注册表、运行堆栈、虚拟机的上下文等数据。

从一个主线程（特指 lua 虚拟机中的线程，即 coroutine）中创建出来的新的 lua_State 会共享大部分数据，但会拥有一个独立的运行堆栈。所以一个线程对象拥有一个lua_State。

lua_State共享的数据部分是全局状态机（包含GC的数据）。lua_State 的运行堆栈为调用栈，lua_State 的数据栈包含当前调用栈信息。

Lua缓存可能会占用大量内存。如果在同一个节点上同时执行同一个UDF脚本足够多的次数，则服务器将缓存最多 128 个 Lua state。

取消注册相关的UDF模型应销毁其所有的缓存条目。然后等待 5~10分钟，以完成 Lua 的垃圾收集。

缓存条目可能会非常大，因为Lua state包含lib和其他开销。缓存系统是性能（速度）和内存使用之间的折衷方案。如果在创建此记录时速度不重要，则可以禁用缓存。或者，您可以使用缓存，但降低UDF调用率，以使缓存不太可能达到其128个条目的最大值。一旦UDF全部完成并且有 128 个缓存条目，如果随后运行并完成更多的UDF，则缓存使用的内存不应增加。如果内存确实继续增长，则表明内存在某处泄漏，或者Lua的垃圾回收无法正常工作。

每个UDF调用都需要一个Lua state才能执行。如果有可用的缓存state，则UDF会使用它并使用它。否则，将生成一个新的Lua state（该状态分配内存，并且当然会花费一些时间），而UDF使用该 state 。当UDF完成时，与其内部操作的记录相关联的内存应被释放，部分方法是调用Lua的垃圾收集器，后者应释放用于处理UDF中的数据的存储。然后，除非缓存中已经有128个条目，否则Lua state 将返回到缓存，在这种情况下，只需关闭Lua state即可释放它所使用的所有内容（这也可能部分取决于Lua中的垃圾回收） 。

不会有record内容应该被缓存，因此UDF调用访问多少记录无关紧要。